Functions
{
    Pure function:
        -   It does not change any objects or variables that existed before it was called.
        -   Same inputs, same output. Given the same inputs, a pure function should always return the same result.
        Ex: function sum(a, b) {
		        return a + b;
			}

    Functional programming:
        -   The function and the data must be totally separated. Function should not be dependant on external variables. All requirements should be passed in parameters.
        -   Functions are treated as first class citizens, i.e., function can be assigned to a variable, passed as an argument and also can be returned from another function.
}

Objects
{
    Computed property names:
        -   To use a variable's value as the key name in an object, wrap that variable with [<variable_here>]. Usually used while dynamically updating a value in the object.
        -   Useful while updating/creating an object in a loop.
        -   Read for more info. -> https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Object_initializer#computed_property_names
        Ex:	const [inputData, setInputData] = useState({
                name: "a",
                username: "b",
                email: "c",
            });

            const handleInputChange = (e) => {
                let name = e.target.name;
                let value = e.target.value;
                setInputData({ ...inputData, [name]: value });
            };
}

Event Loop
{
    -   Function call stack > async events > sent to event queue > put back to call stack once its free
}

Loops/Iterations
{
    Labelled statements/iterators:  A label can be added to the iterators like for, for-in, for-of etc. and that label can be used to continue or break anytime while looping.
	loop1:  for (let i = 0; i < 5; i++) {
				if (i === 1) {
					continue loop1;
				}
				str = str + i;
			}

			console.log(str);   // output: "0234"
}